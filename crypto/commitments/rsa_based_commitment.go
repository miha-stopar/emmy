package commitments

import (
	"github.com/xlab-si/emmy/crypto/common"
	"github.com/xlab-si/emmy/crypto/dlog"
	"math/big"
	"crypto/rand"
	"fmt"
	"errors"
	"github.com/xlab-si/emmy/zkp/preimage"
)

// ProveBitCommitment demonstrates how committer can prove that a commitment contains
// 0 or 1. This is achieved by using PartialPreimageProver.
func ProveBitCommitment() (bool, error) {
	receiver, err := NewRSABasedCommitReceiver(1024)
	if err != nil {
		return false, err
	}

	committer, err := NewRSABasedCommitter(receiver.RSA.N, receiver.RSA.E, receiver.Y)
	if err != nil {
		return false, err
	}

	u1, _ := committer.GetCommitMsg(big.NewInt(0))
	// commitment contains 0: u1 = commitment(0)
	// if we would like to have a commitment that contains 1, we
	// need to use u1 = Y^(-1) * c where c is committer.GetCommitMsg(big.NewInt(1))
	_, v1 := committer.GetDecommitMsg() // v1 is a random r used in commitment: c = Y^a * r^q mod N

	// receiver.RSA.E is Q
	H := common.NewZnGroup(receiver.RSA.N)
	u2 := H.GetRandomElement()

	prover := preimage.NewPartialPreimageProver(committer.RSA.Exp, H, committer.RSA.E, v1, u1, u2)
	verifier := preimage.NewPartialPreimageVerifier(receiver.RSA.Exp, H, receiver.RSA.E)

	pair1, pair2 := prover.GetProofRandomData()

	verifier.SetProofRandomData(pair1, pair2)
	challenge := verifier.GetChallenge()

	c1, z1, c2, z2 := prover.GetProofData(challenge)
	verified := verifier.Verify(c1, z1, c2, z2)

	return verified, nil
}

// GenerateRSABasedQOneWay generates RSA. RSA.Exp presents q-one-way homomorphism.
// QOneWayHomomorphism has the following property: it is difficult to compute a preimage of y^i
// for i < Q, but it is easy for i = Q. For RSABased computing preimage for y^Q is trivial: it is y.
func GenerateRSABasedQOneWay(nBitLength int) (*dlog.RSA, func(*big.Int) *big.Int, error) {
	rsa, err := dlog.NewRSA(nBitLength)
	if err != nil {
		return nil, nil, err
	}
	q, err := rand.Prime(rand.Reader, rsa.N.BitLen() + 1)
	if err != nil {
		return nil, nil, err
	}
	if q.Cmp(rsa.N) < 1 {
		return nil, nil, fmt.Errorf("Q must be > N")
	}
	rsa.E = q
	// given y^Q, homomorphismInv can compute x such that homomorphism(x) = y^Q.
	// Note: it takes y as input, not y^Q.
	// For RSABased it is trivial: identity. For other QOneHomomorphisms it might be different.
	homomorphismInv := func (y *big.Int) *big.Int {
		return y
	}

	return rsa, homomorphismInv, nil
}

// RSABasedCommitter implements commitment scheme based on (RSA based) q-one-way group homomorphism
// (scheme proposed by Cramer and Damgard). Commitment schemes based on q-one-way homomorphism
// have some nice properties - for example it can be proved in zero knowledge that a commitment
// contains 0 or 1 (see ProveBitCommitment).
type RSABasedCommitter struct {
	RSA *dlog.RSA
	Y *big.Int
	committedValue *big.Int
	r *big.Int
}

// NewRSABasedCommitter takes n, q, y parameters which are generated by RSABasedCommitReceiver.
func NewRSABasedCommitter(n, q, y *big.Int) (*RSABasedCommitter, error) {
	// y must be from Im(f) where f(x) = x^q mod n, that means gcd(y, n) must be 1:
	yIsValid := new(big.Int).GCD(nil, nil, y, n).Cmp(big.NewInt(1)) == 0
	if !yIsValid {
		return nil, fmt.Errorf("Y is not valid")
	}
	rsa := dlog.NewPublicRSA(n, q)
	return &RSABasedCommitter{
		RSA: rsa,
		Y: y,
	}, nil
}

func (committer *RSABasedCommitter) GetCommitMsg(a *big.Int) (*big.Int, error) {
	if a.Cmp(committer.RSA.E) != -1 {
		err := errors.New("the committed value needs to be < Q")
		return nil, err
	}
	c, r := committer.computeCommitment(a)
	committer.committedValue = a
	committer.r = r
	return c, nil
}

func (committer *RSABasedCommitter) computeCommitment(a *big.Int) (*big.Int, *big.Int) {
	// Y^a * r^Q mod N, where r is random from Z_N*
	r := common.GetZnInvertibleElement(committer.RSA.N)
	t1 := new(big.Int).Exp(committer.Y, a, committer.RSA.N)
	t2 := committer.RSA.Exp(r) // q-one-way homomorphism image
	c := new(big.Int).Mul(t1, t2)
	c.Mod(c, committer.RSA.N)
	return c, r
}

func (committer *RSABasedCommitter) GetDecommitMsg() (*big.Int, *big.Int) {
	return committer.committedValue, committer.r
}

// GetCommitmentToMultiplication receives a, b, u where u is a random integer used in
// commitment B to b (B = y^b * QOneWayHomomorphism(u)). It returns commitment C to c = a * b,
// random integer o where C = y^(a*b) * QOneWayHomomorphism(o), and integer t such that
// C = B^a * QOneWayHomomorphism(t).
func (committer *RSABasedCommitter) GetCommitmentToMultiplication(a, b, u *big.Int) (*big.Int,
	*big.Int, *big.Int) {
	H := common.NewZnGroup(committer.RSA.N)
	c := H.Mul(a, b)
	C, o := committer.computeCommitment(c)
	// We want C = B^a * f(t). We know C = y^(a*b) * f(o) and B^a = y^(a*b) * f(u)^a.
	// t = o * u^(-a)
	uToa := H.Exp(u, a)
	uToaInv := H.Inv(uToa)
	t := H.Mul(o, uToaInv)
	return C, o, t
}

type RSABasedCommitReceiver struct {
	RSA *dlog.RSA // with E = Q; Q prime, Q > n
	HomomorphismInv func(*big.Int) *big.Int
	Y *big.Int
	x *big.Int
	commitment *big.Int
}

func NewRSABasedCommitReceiver(nBitLength int) (*RSABasedCommitReceiver, error) {
	rsa, homomorphismInv, err := GenerateRSABasedQOneWay(nBitLength)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	// gcd(q, phi(N)) is prime because q is prime and q > N > phi(N)
	// let's choose some x from Z_n*
	x, err := rand.Prime(rand.Reader, rsa.N.BitLen() - 1)
	if err != nil {
		return nil, err
	}
	g := new(big.Int)
	g.GCD(nil, nil, x, rsa.N)
	if g.Cmp(big.NewInt(1)) != 0 {
		return nil, fmt.Errorf("gcd(x, N) must be 1")
	}
	y := rsa.Exp(x) // q-one-way homomorphism image

	return &RSABasedCommitReceiver{
		RSA: rsa,
		HomomorphismInv: homomorphismInv,
		Y: y,
		x: x,
	}, nil
}

// When receiver receives a commitment, it stores the value using SetCommitment method.
func (receiver *RSABasedCommitReceiver) SetCommitment(c *big.Int) {
	receiver.commitment = c
}

func (receiver *RSABasedCommitReceiver) CheckDecommitment(r, a *big.Int) bool {
	t1 := new(big.Int).Exp(receiver.Y, a, receiver.RSA.N)
	t2 := new(big.Int).Exp(r, receiver.RSA.E, receiver.RSA.N)
	c := new(big.Int).Mul(t1, t2)
	c.Mod(c, receiver.RSA.N)

	var success bool
	if c.Cmp(receiver.commitment) == 0 {
		success = true
	} else {
		success = false
	}

	return success
}

