package commitments

import (
	"github.com/xlab-si/emmy/crypto/common"
	"github.com/xlab-si/emmy/crypto/dlog"
	"math/big"
	"crypto/rand"
	"fmt"
	"errors"
)

// GenerateRSABasedQOneWay generates RSA, RSA.Exp presents q-one-way homomorphism.
func GenerateRSABasedQOneWay(nBitLength int) (*dlog.RSA, error) {
	rsa, err := dlog.NewRSA(nBitLength)
	if err != nil {
		return nil, err
	}
	q, err := rand.Prime(rand.Reader, rsa.N.BitLen() + 1)
	if err != nil {
		return nil, err
	}
	if q.Cmp(rsa.N) < 1 {
		return nil, fmt.Errorf("Q must be > N")
	}
	rsa.E = q

	return rsa, nil
}

// RSABasedCommitter implements commitment scheme based on (RSA based) group homomorphism
// (scheme proposed by Cramer and Damgard).
type RSABasedCommitter struct {
	RSA *dlog.RSA
	Y *big.Int
	committedValue *big.Int
	r *big.Int
}

// NewRSABasedCommitter takes n, q, y parameters which are generated by RSABasedCommitReceiver.
func NewRSABasedCommitter(n, q, y *big.Int) (*RSABasedCommitter, error) {
	// y must be from Im(f) where f(x) = x^q mod n, that means gcd(y, n) must be 1:
	yIsValid := new(big.Int).GCD(nil, nil, y, n).Cmp(big.NewInt(1)) == 0
	if !yIsValid {
		return nil, fmt.Errorf("Y is not valid")
	}
	rsa := dlog.NewPublicRSA(n, q)
	return &RSABasedCommitter{
		RSA: rsa,
		Y: y,
	}, nil
}

func (committer *RSABasedCommitter) GetCommitMsg(a *big.Int) (*big.Int, error) {
	if a.Cmp(committer.RSA.E) != -1 {
		err := errors.New("the committed value needs to be < Q")
		return nil, err
	}
	// Y^a * r^Q mod N, where r is random from Z_N*
	r := common.GetZnInvertibleElement(committer.RSA.N)
	t1 := new(big.Int).Exp(committer.Y, a, committer.RSA.N)
	t2 := committer.RSA.Exp(r) // q-one-way homomorphism image
	c := new(big.Int).Mul(t1, t2)
	c.Mod(c, committer.RSA.N)

	committer.committedValue = a
	committer.r = r
	return c, nil
}

func (committer *RSABasedCommitter) GetDecommitMsg() (*big.Int, *big.Int) {
	return committer.committedValue, committer.r
}

type RSABasedCommitReceiver struct {
	RSA *dlog.RSA // with E = Q; Q prime, Q > n
	Y *big.Int
	x *big.Int
	commitment *big.Int
}

func NewRSABasedCommitReceiver(nBitLength int) (*RSABasedCommitReceiver, error) {
	rsa, err := GenerateRSABasedQOneWay(nBitLength)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	// gcd(q, phi(N)) is prime because q is prime and q > N > phi(N)
	// let's choose some x from Z_n*
	x, err := rand.Prime(rand.Reader, rsa.N.BitLen() - 1)
	if err != nil {
		return nil, err
	}
	g := new(big.Int)
	g.GCD(nil, nil, x, rsa.N)
	if g.Cmp(big.NewInt(1)) != 0 {
		return nil, fmt.Errorf("gcd(x, N) must be 1")
	}
	y := rsa.Exp(x) // q-one-way homomorphism image

	return &RSABasedCommitReceiver{
		RSA: rsa,
		Y: y,
		x: x,
	}, nil
}

// When receiver receives a commitment, it stores the value using SetCommitment method.
func (receiver *RSABasedCommitReceiver) SetCommitment(c *big.Int) {
	receiver.commitment = c
}

func (receiver *RSABasedCommitReceiver) CheckDecommitment(r, a *big.Int) bool {
	t1 := new(big.Int).Exp(receiver.Y, a, receiver.RSA.N)
	t2 := new(big.Int).Exp(r, receiver.RSA.E, receiver.RSA.N)
	c := new(big.Int).Mul(t1, t2)
	c.Mod(c, receiver.RSA.N)

	var success bool
	if c.Cmp(receiver.commitment) == 0 {
		success = true
	} else {
		success = false
	}

	return success
}

