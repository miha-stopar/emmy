/*
 * Copyright 2017 XLAB d.o.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package commitmentzkp

import (
	"math/big"

	"fmt"

	"github.com/xlab-si/emmy/crypto/commitments"
)

// DFCommitmentRangeProver proves that the commitment hides a number x such that a <= x <= b.
// Given c, prove that c = g^x * h^r (mod n) where a <= x <= b.
type DFCommitmentRangeProver struct {
	prover1 *DFCommitmentPositiveProver
	prover2 *DFCommitmentPositiveProver
}

func NewDFCommitmentRangeProver(committer *commitments.DamgardFujisakiCommitter,
	x, a, b *big.Int, challengeSpaceSize int) (*DFCommitmentRangeProver, error) {

	// We will prove that b-x >= 0 and x-a >= 0.
	bx := new(big.Int).Sub(b, x)
	xa := new(big.Int).Sub(x, a)
	_, r := committer.GetDecommitMsg()

	rNeg := new(big.Int).Neg(r) // we act as commitment is: g^b / (g^x * h^r) = g^(b-x) * h^(-r)
	prover1, err := NewDFCommitmentPositiveProver(committer, bx, rNeg,
		challengeSpaceSize)
	if err != nil {
		return nil, fmt.Errorf("error in instantiating DFCommitmentPositiveProver")
	}
	prover2, err := NewDFCommitmentPositiveProver(committer, xa, r,
		challengeSpaceSize)
	if err != nil {
		return nil, fmt.Errorf("error in instantiating DFCommitmentPositiveProver")
	}

	return &DFCommitmentRangeProver{
		prover1: prover1,
		prover2: prover2,
	}, nil
}

func (p *DFCommitmentRangeProver) GetProofRandomData() ([]*big.Int, []*big.Int) {
	proofRandomData1 := p.prover1.GetProofRandomData()
	proofRandomData2 := p.prover2.GetProofRandomData()
	return proofRandomData1, proofRandomData2
}

func (p *DFCommitmentRangeProver) GetProofData(challenges1, challenges2 []*big.Int) ([]*big.Int, []*big.Int, error) {
	proofData1 := p.prover1.GetProofData(challenges1)
	proofData2 := p.prover2.GetProofData(challenges2)
	return proofData1, proofData2, nil
}

// GetVerifierInitializationData returns data that are needed by DFCommitmentRangeVerifier
// and are known only after the initialization of DFCommitmentRangeProver.
func (p *DFCommitmentRangeProver) GetVerifierInitializationData() ([]*big.Int, []*big.Int, []*big.Int,
	[]*big.Int) {
	return p.prover1.smallCommitments, p.prover1.bigCommitments, p.prover2.smallCommitments,
		p.prover2.bigCommitments
}

// DFRangeProof presents all three messages in sigma protocol - useful when challenge
// is generated by prover via Fiat-Shamir.
type DFRangeProof struct {
	ProofRandomData1 []*big.Int
	ProofRandomData2 []*big.Int
	Challenges1      []*big.Int
	Challenges2      []*big.Int
	ProofData1       []*big.Int
	ProofData2       []*big.Int
}

func NewDFRangeProof(proofRandomData1, proofRandomData2, challenges1, challenges2, proofData1,
	proofData2 []*big.Int) *DFRangeProof {
	return &DFRangeProof{
		ProofRandomData1: proofRandomData1,
		ProofRandomData2: proofRandomData2,
		Challenges1:      challenges1,
		Challenges2:      challenges2,
		ProofData1:       proofData1,
		ProofData2:       proofData2,
	}
}

type DFCommitmentRangeVerifier struct {
	verifier1       *DFCommitmentPositiveVerifier
	verifier2       *DFCommitmentPositiveVerifier
	proofRandomData []*big.Int
}

func NewDFCommitmentRangeVerifier(receiver *commitments.DamgardFujisakiReceiver, a, b *big.Int,
	smallCommitments1, bigCommitments1, smallCommitments2, bigCommitments2 []*big.Int,
	challengeSpaceSize int) (*DFCommitmentRangeVerifier, error) {

	// receiverCommitment1 = g^b / c
	receiverCommitment1 := receiver.QRSpecialRSA.Exp(receiver.G, b)
	cInv := receiver.QRSpecialRSA.Inv(receiver.Commitment)
	receiverCommitment1 = receiver.QRSpecialRSA.Mul(receiverCommitment1, cInv)

	verifier1, err := NewDFCommitmentPositiveVerifier(receiver, receiverCommitment1, smallCommitments1,
		bigCommitments1, challengeSpaceSize)
	if err != nil {
		return nil, fmt.Errorf("error in instantiating DFCommitmentPositiveVerifier")
	}

	// receiverCommitment2 = c / g^a
	gToa := receiver.QRSpecialRSA.Exp(receiver.G, a)
	gToaInv := receiver.QRSpecialRSA.Inv(gToa)
	receiverCommitment2 := receiver.QRSpecialRSA.Mul(receiver.Commitment, gToaInv)

	verifier2, err := NewDFCommitmentPositiveVerifier(receiver, receiverCommitment2, smallCommitments2,
		bigCommitments2, challengeSpaceSize)
	if err != nil {
		return nil, fmt.Errorf("error in instantiating DFCommitmentPositiveVerifier")
	}

	return &DFCommitmentRangeVerifier{
		verifier1: verifier1,
		verifier2: verifier2,
	}, nil
}

func (v *DFCommitmentRangeVerifier) GetChallenges() ([]*big.Int, []*big.Int) {
	challenges1 := v.verifier1.GetChallenges()
	challenges2 := v.verifier2.GetChallenges()
	return challenges1, challenges2
}

func (v *DFCommitmentRangeVerifier) SetProofRandomData(proofRandomData1, proofRandomData2 []*big.Int) error {
	err := v.verifier1.SetProofRandomData(proofRandomData1)
	if err != nil {
		return err
	}
	err = v.verifier2.SetProofRandomData(proofRandomData2)
	if err != nil {
		return err
	}
	return nil
}

// SetChallenges is used when Fiat-Shamir is used - when challenge is generated using hash by the prover.
func (v *DFCommitmentRangeVerifier) SetChallenges(challenges1, challenges2 []*big.Int) {
	v.verifier1.SetChallenges(challenges1)
	v.verifier2.SetChallenges(challenges2)
}

func (v *DFCommitmentRangeVerifier) Verify(proofData1, proofData2 []*big.Int) (bool, error) {
	return v.verifier1.Verify(proofData1) && v.verifier2.Verify(proofData2), nil
}
